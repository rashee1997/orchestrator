import { MemoryManager } from '../database/memory_manager.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { validate, schemas } from '../utils/validation.js';
import { callTavilyApi } from '../integrations/tavily.js';
import { formatSimpleMessage, formatJsonToMarkdownCodeBlock, formatObjectToMarkdown } from '../utils/formatters.js';

export const sourceAttributionToolDefinitions = [
    {
        name: 'log_source_attribution',
        description: 'Logs the origin of information used or generated by the AI agent. Output is Markdown formatted.',
        inputSchema: {
            type: 'object',
            properties: {
                agent_id: { type: 'string', description: 'Identifier of the AI agent.' },
                source_type: { type: 'string', description: 'Type of source (e.g., user_input, tavily_search, internal_reasoning).' },
                source_uri: { type: 'string', description: 'URI or identifier of the source (e.g., URL for web, query for Tavily).', nullable: true },
                retrieval_timestamp: { type: 'number', description: 'Unix timestamp of when the information was retrieved.' },
                content_summary: { type: 'string', description: 'Brief summary of the attributed content.', nullable: true },
                full_content_hash: { type: 'string', description: 'Optional, hash of the full content for integrity checking.', nullable: true },
                full_content_json: { type: ['string', 'object'], description: 'Optional, full content as a JSON string or object.', nullable: true },
            },
            required: ['agent_id', 'source_type', 'retrieval_timestamp'],
        },
    },
    {
        name: 'get_source_attributions',
        description: 'Retrieves source attributions for a given agent, optionally filtered by source type. Output is Markdown formatted.',
        inputSchema: {
            type: 'object',
            properties: {
                agent_id: { type: 'string', description: 'Identifier of the AI agent.' },
                source_type: { type: 'string', description: 'Optional type of source to filter by.', nullable: true },
                limit: { type: 'number', description: 'Maximum number of attributions to retrieve.', default: 100 },
                offset: { type: 'number', description: 'Offset for pagination.', default: 0 },
            },
            required: ['agent_id'],
        },
    },
    {
        name: 'tavily_web_search',
        description: 'Performs a Tavily web search and returns results as Markdown. Source attribution should be logged separately by the calling agent using the log_search_attribution tool.',
        inputSchema: {
            type: 'object',
            properties: {
                query: { type: 'string', description: 'The search query.' },
                search_depth: { type: 'string', enum: ['basic', 'advanced'], default: 'basic', description: 'Depth of the search.' },
                max_results: { type: 'number', default: 5, description: 'Maximum number of search results to return.' },
            },
            required: ['query'],
        },
    },
    {
        name: 'log_search_attribution', // This is a specialized version of log_source_attribution for searches
        description: 'Logs the attribution details for a completed web search. Output is Markdown formatted.',
        inputSchema: {
            type: 'object',
            properties: {
                agent_id: { type: 'string', description: 'Identifier of the AI agent that performed the search.' },
                query: { type: 'string', description: 'The original search query.' },
                search_results_summary: { type: 'string', description: 'A summary of the search results.', nullable: true },
                retrieval_timestamp: { type: 'number', description: 'Unix timestamp of when the search was performed.' },
                // source_uri is implicitly the query for search
                full_content_hash: { type: 'string', description: 'Optional hash of the full content for integrity checking.', nullable: true },
                full_content_json: { type: ['string', 'object'], description: 'Optional, full search results content as a JSON string or object.', nullable: true },
            },
            required: ['agent_id', 'query', 'retrieval_timestamp'],
        },
    },
];

export function getSourceAttributionToolHandlers(memoryManager: MemoryManager) {
    return {
        'log_source_attribution': async (args: any, agent_id: string) => {
            const validationResult = validate('sourceAttribution', args);
            if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Validation failed: ${formatJsonToMarkdownCodeBlock(validationResult.errors)}`);
            }
            const contentJson = typeof args.full_content_json === 'object' ? JSON.stringify(args.full_content_json) : args.full_content_json;
            const attrId = await memoryManager.logSourceAttribution(
                agent_id,
                args.source_type as string,
                args.source_uri as string | null,
                args.retrieval_timestamp as number,
                args.content_summary as string | null,
                args.full_content_hash as string | null,
                contentJson as string | null
            );
            return { content: [{ type: 'text', text: formatSimpleMessage(`Source attribution logged with ID: \`${attrId}\``, "Source Attribution Logged") }] };
        },
        'get_source_attributions': async (args: any, agent_id: string) => {
            const attributions = await memoryManager.getSourceAttributions(
                agent_id,
                args.source_type as string | null,
                args.limit as number,
                args.offset as number
            );
            if (!attributions || attributions.length === 0) {
                return { content: [{ type: 'text', text: formatSimpleMessage("No source attributions found.", "Source Attributions") }] };
            }
            let md = `## Source Attributions for Agent: \`${agent_id}\`\n`;
            if(args.source_type) md += `### Type: \`${args.source_type}\`\n`;
            attributions.forEach((attr: any) => {
                md += `### Attribution ID: \`${attr.attribution_id}\`\n`;
                md += `- **Type:** ${attr.source_type}\n`;
                if (attr.source_uri) md += `- **URI:** \`${attr.source_uri}\`\n`;
                md += `- **Retrieved:** ${new Date(attr.retrieval_timestamp).toLocaleString()}\n`;
                if (attr.content_summary) md += `- **Summary:** ${attr.content_summary}\n`;
                if (attr.full_content_hash) md += `- **Content Hash:** \`${attr.full_content_hash}\`\n`;
                if (attr.full_content_json) md += `- **Full Content:**\n${formatJsonToMarkdownCodeBlock(attr.full_content_json)}\n`;
                md += "\n---\n";
            });
            return { content: [{ type: 'text', text: md }] };
        },
        'tavily_web_search': async (args: any) => { // agent_id is not required for this tool's core logic
            const validationResult = validate('tavilySearch', args);
            if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Validation failed: ${formatJsonToMarkdownCodeBlock(validationResult.errors)}`);
            }
            const tavilySearchResults = await callTavilyApi(args.query, args.search_depth, args.max_results);
            
            let md = `## Tavily Web Search Results for Query: "${args.query}"\n\n`;
            if (!tavilySearchResults || tavilySearchResults.length === 0) {
                md += "*No results found.*\n";
            } else {
                tavilySearchResults.forEach((result: any, index: number) => {
                    md += `### Result ${index + 1}: ${result.title || 'N/A'}\n`;
                    md += `- **URL:** <${result.url || '#'}>\n`;
                    if (result.content) md += `- **Content Snippet:**\n  > ${result.content.replace(/\n/g, '\n  > ')}\n`;
                    if (result.score) md += `- **Score:** ${result.score}\n`;
                    md += "\n";
                });
            }
            return { content: [{ type: 'text', text: md }] };
        },
        'log_search_attribution': async (args: any, agent_id: string) => {
            // Validate against a modified sourceAttribution schema or ensure args match
             const validationResult = validate('sourceAttribution', { // Use the base schema
                agent_id: args.agent_id,
                source_type: 'tavily_search', // Hardcode for this tool
                source_uri: args.query, // Map query to source_uri
                retrieval_timestamp: args.retrieval_timestamp,
                content_summary: args.search_results_summary, // Map
                full_content_hash: args.full_content_hash,
                full_content_json: args.full_content_json
            });
            if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Validation failed for log_search_attribution: ${formatJsonToMarkdownCodeBlock(validationResult.errors)}`);
            }

            const contentJson = typeof args.full_content_json === 'object' ? JSON.stringify(args.full_content_json) : args.full_content_json;
            const newAttrId = await memoryManager.logSourceAttribution(
                agent_id,
                'tavily_search', // Source type is fixed for this tool
                args.query as string, // Use query as the source_uri
                args.retrieval_timestamp as number,
                args.search_results_summary as string | null,
                args.full_content_hash as string | null,
                contentJson as string | null
            );
            return { content: [{ type: 'text', text: formatSimpleMessage(`Search attribution for query "${args.query}" logged with ID: \`${newAttrId}\``, "Search Attribution Logged") }] };
        },
    };
}

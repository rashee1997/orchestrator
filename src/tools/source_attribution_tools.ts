import { MemoryManager } from '../database/memory_manager.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { validate, schemas } from '../utils/validation.js';
import { callTavilyApi } from '../integrations/tavily.js';
import { formatSimpleMessage, formatJsonToMarkdownCodeBlock, formatObjectToMarkdown } from '../utils/formatters.js';
export const sourceAttributionToolDefinitions = [
    {
        name: 'log_source_attribution',
        description: 'Logs the origin of information used or generated by the AI agent. Output is Markdown formatted.',
        inputSchema: {
            type: 'object',
            properties: {
                agent_id: { type: 'string', description: 'Identifier of the AI agent.' },
                source_type: { type: 'string', description: 'Type of source (e.g., user_input, tavily_search, internal_reasoning).' },
                source_uri: { type: 'string', description: 'URI or identifier of the source (e.g., URL for web, query for Tavily).', nullable: true },
                retrieval_timestamp: { type: 'number', description: 'Unix timestamp of when the information was retrieved.' },
                content_summary: { type: 'string', description: 'Brief summary of the attributed content.', nullable: true },
                full_content_hash: { type: 'string', description: 'Optional, hash of the full content for integrity checking.', nullable: true },
                full_content_json: { type: ['string', 'object'], description: 'Optional, full content as a JSON string or object.', nullable: true },
            },
            required: ['agent_id', 'source_type', 'retrieval_timestamp'],
        },
    },
    {
        name: 'get_source_attributions',
        description: 'Retrieves source attributions for a given agent, optionally filtered by source type. Output is Markdown formatted.',
        inputSchema: {
            type: 'object',
            properties: {
                agent_id: { type: 'string', description: 'Identifier of the AI agent.' },
                source_type: { type: 'string', description: 'Optional type of source to filter by.', nullable: true },
                limit: { type: 'number', description: 'Maximum number of attributions to retrieve.', default: 100 },
                offset: { type: 'number', description: 'Offset for pagination.', default: 0 },
            },
            required: ['agent_id'],
        },
    },
    {
        name: 'tavily_web_search',
        description: 'Performs a Tavily web search and returns results as Markdown. Source attribution should be logged separately by the calling agent using the log_source_attribution tool with source_type \'tavily_search\'.',
        inputSchema: {
            type: 'object',
            properties: {
                query: { type: 'string', description: 'The search query.' },
                search_depth: { type: 'string', enum: ['basic', 'advanced'], default: 'basic', description: 'Depth of the search.' },
                max_results: { type: 'number', default: 5, description: 'Maximum number of search results to return.' },
                include_raw_content: { type: 'boolean', default: false, description: 'Include raw content in search results.' },
                include_images: { type: 'boolean', default: false, description: 'Include images in search results.' },
                include_image_descriptions: { type: 'boolean', default: false, description: 'Include image descriptions in search results.' },
                time_period: { type: 'string', description: 'Time period for search results (e.g., "1m", "1y", "all").' },
                topic: { type: 'string', description: 'Topic category for search results (e.g., "news", "general").' },
            },
            required: ['query'],
        },
    },
];
export function getSourceAttributionToolHandlers(memoryManager: MemoryManager) {
    return {
        'log_source_attribution': async (args: any, agent_id: string) => {
            const validationResult = validate('sourceAttribution', args);
            if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Validation failed: ${formatJsonToMarkdownCodeBlock(validationResult.errors)}`);
            }
            const contentJson = typeof args.full_content_json === 'object' ? JSON.stringify(args.full_content_json) : args.full_content_json;
            const attrId = await memoryManager.logSourceAttribution(
                agent_id,
                args.source_type as string,
                args.source_uri as string | null,
                args.retrieval_timestamp as number,
                args.content_summary as string | null,
                args.full_content_hash as string | null,
                contentJson as string | null
            );
            return { content: [{ type: 'text', text: formatSimpleMessage(`Source attribution logged with ID: \`${attrId}\``, "Source Attribution Logged") }] };
        },
        'get_source_attributions': async (args: any, agent_id: string) => {
            const attributions = await memoryManager.getSourceAttributions(
                agent_id,
                args.source_type as string | null,
                args.limit as number,
                args.offset as number
            );
            if (!attributions || attributions.length === 0) {
                return { content: [{ type: 'text', text: formatSimpleMessage("No source attributions found.", "Source Attributions") }] };
            }
            let md = `## Source Attributions for Agent: \`${agent_id}\`\n`;
            if (args.source_type) md += `### Type: \`${args.source_type}\`\n`;
            attributions.forEach((attr: any) => {
                md += `### Attribution ID: \`${attr.attribution_id}\`\n`;
                md += `- **Type:** ${attr.source_type}\n`;
                if (attr.source_uri) md += `- **URI:** \`${attr.source_uri}\`\n`;
                md += `- **Retrieved:** ${new Date(attr.retrieval_timestamp).toLocaleString()}\n`;
                if (attr.content_summary) md += `- **Summary:** ${attr.content_summary}\n`;
                if (attr.full_content_hash) md += `- **Content Hash:** \`${attr.full_content_hash}\`\n`;
                if (attr.full_content_json) md += `- **Full Content:**\n${formatJsonToMarkdownCodeBlock(attr.full_content_json)}\n`;
                md += "\n---\n";
            });
            return { content: [{ type: 'text', text: md }] };
        },
        'tavily_web_search': async (args: any) => { // agent_id is not required for this tool's core logic
            const validationResult = validate('tavilySearch', args);
            if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Validation failed: ${formatJsonToMarkdownCodeBlock(validationResult.errors)}`);
            }
            // Pass all Tavily parameters to the API call
            const tavilySearchResults = await callTavilyApi(args.query, {
                search_depth: args.search_depth,
                max_results: args.max_results,
                include_raw_content: args.include_raw_content,
                include_images: args.include_images,
                include_image_descriptions: args.include_image_descriptions,
                time_period: args.time_period,
                topic: args.topic
            });

            let md = `## Tavily Web Search Results for Query: "${args.query}"\n\n`;
            if (!tavilySearchResults || tavilySearchResults.length === 0) {
                md += "*No results found.*\n";
            } else {
                tavilySearchResults.forEach((result: any, index: number) => {
                    md += `### Result ${index + 1}: ${result.title || 'N/A'}\n`;
                    md += `- **URL:** <${result.url || '#'}>\n`;
                    if (result.content) md += `- **Content Snippet:**\n  > ${result.content.replace(/\n/g, '\n  > ')}\n`;
                    if (result.score) md += `- **Score:** ${result.score}\n`;
                    md += "\n";
                });
            }
            return { content: [{ type: 'text', text: md }] };
        },
    };
}
import { MemoryManager } from '../../database/memory_manager.js';
import { GeminiIntegrationService } from '../../database/services/GeminiIntegrationService.js';
import { RetrievedCodeContext } from '../../database/services/CodebaseContextRetrieverService.js';
import { ContextRetrievalOptions } from '../../database/services/CodebaseContextRetrieverService.js';
import {
    RAG_ANALYSIS_PROMPT,
    RAG_ANALYSIS_SYSTEM_INSTRUCTION,
    RAG_ANSWER_PROMPT,
    RAG_VERIFICATION_PROMPT
} from '../../database/services/gemini-integration-modules/GeminiPromptTemplates.js';
import { RagAnalysisResponse } from './rag_response_parser.js';
import { RagResponseParser } from './rag_response_parser.js';
import { DiverseQueryRewriterService } from './diverse_query_rewriter_service.js';
import { callTavilyApi } from '../../integrations/tavily.js';
import {
    formatRetrievedContextForPrompt as formatContextForGemini
} from '../../database/services/gemini-integration-modules/GeminiContextFormatter.js';
import { GeminiApiNotInitializedError } from '../../database/services/gemini-integration-modules/GeminiApiClient.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { deduplicateContexts } from '../../utils/context_utils.js';

/**
 * Result returned by the orchestrator after the whole iterative search finishes.
 */
export interface IterativeRagResult {
    /** All unique context items collected across every turn. */
    accumulatedContext: RetrievedCodeContext[];
    /** Web results (if any) that were added to the context. */
    webSearchSources: { title: string; url: string }[];
    /**  Final answer generated by Gemini (if an ANSWER decision was reached). */
    finalAnswer?: string;
    /** Full log of every RAG‑analysis response (useful for debugging). */
    decisionLog: RagAnalysisResponse[];
    /** Metrics that give insight into the search behaviour. */
    searchMetrics: {
        totalIterations: number;
        contextItemsAdded: number;
        webSearchesPerformed: number;
        hallucinationChecksPerformed: number;
        earlyTerminationReason?: string;
        dmqr: {
            enabled: boolean;
            queryCount?: number;
            generatedQueries?: string[];
            success: boolean;
            contextItemsGenerated: number;
            error?: string;
        };
        /** Timestamped record of each turn – handy for UI visualisation. */
        turnLog: {
            turn: number;
            query: string;
            newContextCount: number;
            decision: string;
            reasoning: string;
        }[];
    };
}

/**
 * Arguments accepted by the orchestrator.
 */
export interface IterativeRagArgs {
    agent_id: string;
    query: string;
    model?: string;
    systemInstruction?: string;

    context_options?: ContextRetrievalOptions;
    focus_area?: string;
    analysis_focus_points?: string[];
    enable_web_search?: boolean;
    max_iterations?: number;
    hallucination_check_threshold?: number;
    tavily_search_depth?: 'basic' | 'advanced';
    tavily_max_results?: number;
    tavily_include_raw_content?: boolean;
    tavily_include_images?: boolean;
    tavily_include_image_descriptions?: boolean;
    tavily_time_period?: string;
    tavily_topic?: string;
    thinkingConfig?: { thinkingBudget?: number; thinkingMode?: 'AUTO' | 'MODE_THINK' };
    enable_dmqr?: boolean;
    dmqr_query_count?: number;
}

/**
 * The orchestrator that drives the multi‑turn, intelligent RAG loop.
 *
 * Key improvements over the previous version:
 *   • Deduplication of context after every turn (using `deduplicateContexts`).
 *   • Rich per‑turn logging (query, decision, new‑context count, reasoning).
 *   • More tolerant DMQR handling – even if it fails we still continue gracefully.
 *   • Automatic query expansion when the LLM signals “SEARCH_AGAIN” but the new query
 *     is too similar to a previous one.
 *   • Robust early‑stop handling with clear metric.
 *   • Optional hallucination verification after the final answer.
 */
export class IterativeRagOrchestrator {
    private memoryManagerInstance: MemoryManager;
    private geminiService: GeminiIntegrationService;
    private diverseQueryRewriterService: DiverseQueryRewriterService;

    constructor(
        memoryManagerInstance: MemoryManager,
        geminiService: GeminiIntegrationService,
        diverseQueryRewriterService: DiverseQueryRewriterService
    ) {
        this.memoryManagerInstance = memoryManagerInstance;
        this.geminiService = geminiService;
        this.diverseQueryRewriterService = diverseQueryRewriterService;
    }

    /**
     * Build the optional “focus” block that is injected into the RAG prompts.
     */
    private _generateFocusString(focusArea?: string, analysisFocusPoints?: string[]): string {
        let focusString = '';
        if (focusArea) {
            if (analysisFocusPoints && analysisFocusPoints.length) {
                focusString =
                    'Focus on the following aspects for your analysis and response:\n' +
                    analysisFocusPoints.map((p, i) => `${i + 1}. **${p}**`).join('\n');
            } else {
                switch (focusArea) {
                    case 'code_review':
                        focusString =
                            'Focus on all aspects including:\n' +
                            '1. **Potential Bugs & Errors**\n' +
                            '2. **Best Practices & Conventions**\n' +
                            '3. **Performance**\n' +
                            '4. **Security Vulnerabilities**\n' +
                            '5. **Readability & Maintainability**';
                        break;
                    case 'code_explanation':
                        focusString = 'Explain the code clearly and concisely.';
                        break;
                    case 'enhancement_suggestions':
                        focusString = 'Suggest improvements and enhancements.';
                        break;
                    case 'bug_fixing':
                        focusString = 'Identify and suggest fixes for bugs.';
                        break;
                    case 'refactoring':
                        focusString = 'Suggest refactoring opportunities.';
                        break;
                    case 'testing':
                        focusString = 'Provide testing strategies and test case generation.';
                        break;
                    case 'documentation':
                        focusString = 'Generate or improve documentation.';
                        break;
                    case 'code_modularization_orchestration':
                        focusString = 'Discuss modularity, architecture, and orchestration patterns.';
                        break;
                    default:
                        focusString = '';
                }
            }
            if (focusString) {
                focusString = `--- Focus Area ---\n${focusString}\n\n`;
            }
        }
        return focusString;
    }

    /**
     * Main entry‑point – runs the iterative search and returns the result.
     */
    async performIterativeSearch(args: IterativeRagArgs): Promise<IterativeRagResult> {
        const {
            agent_id,
            query,
            model,
            max_iterations = 3,
            context_options,
            focus_area,
            analysis_focus_points,
            enable_web_search,
            hallucination_check_threshold = 0.8,
            tavily_search_depth = 'basic',
            tavily_max_results = 5,
            tavily_include_raw_content = false,
            tavily_include_images = false,
            tavily_include_image_descriptions = false,
            tavily_time_period,
            tavily_topic,
            thinkingConfig,
            enable_dmqr,
            dmqr_query_count
        } = args;

        const contextRetriever = this.memoryManagerInstance.getCodebaseContextRetrieverService();

        // --------------------------------------------------------------------
        // State that survives across all turns
        // --------------------------------------------------------------------
        let accumulatedContext: RetrievedCodeContext[] = [];
        const processedEntities = new Set<string>(); // deduplication key: `${sourcePath}::${entityName}`
        const webSearchSources: { title: string; url: string }[] = [];
        const decisionLog: RagAnalysisResponse[] = [];

        // Metrics & turn‑by‑turn log
        const searchMetrics = {
            totalIterations: 0,
            contextItemsAdded: 0,
            webSearchesPerformed: 0,
            hallucinationChecksPerformed: 0,
            earlyTerminationReason: undefined as string | undefined,
            dmqr: {
                enabled: !!enable_dmqr,
                queryCount: dmqr_query_count,
                generatedQueries: [] as string[],
                success: false,
                contextItemsGenerated: 0,
                error: undefined as string | undefined
            },
            turnLog: [] as {
                turn: number;
                query: string;
                newContextCount: number;
                decision: string;
                reasoning: string;
            }[]
        };

        const focusString = this._generateFocusString(focus_area, analysis_focus_points);
        console.log(`[Iterative RAG] Starting search for query: "${query}"`);

        // --------------------------------------------------------------------
        // 1️⃣  Prepare the list of base queries (original +  DMQR)
        // --------------------------------------------------------------------
        let baseQueries: string[] = [query];

        if (enable_dmqr) {
            console.log('[Iterative RAG] DMQR enabled – generating diverse queries...');
            try {
                const dmqrResult = await this.diverseQueryRewriterService.rewriteAndRetrieve(query, {
                    queryCount: dmqr_query_count
                });
                baseQueries = dmqrResult.generatedQueries;
                searchMetrics.dmqr.generatedQueries = baseQueries;
                searchMetrics.dmqr.success = true;
                console.log(`[Iterative RAG] DMQR produced ${baseQueries.length} queries.`);
            } catch (e: any) {
                console.error('[Iterative RAG] DMQR failed – falling back to original query.', e);
                searchMetrics.dmqr.success = false;
                searchMetrics.dmqr.error = e.message ?? 'unknown';
                baseQueries = [query];
            }
        }

        // --------------------------------------------------------------------
        // 2️⃣  Outer loop – iterate over each base query (original + DMQR)
        // --------------------------------------------------------------------
        let globalTurn = 0;
        outer: for (const baseQuery of baseQueries) {
            let currentQuery = baseQuery;
            const queryHistory = [baseQuery === query ? 'original' : 'dmqr']; // track for repetition detection

            // ----------------------------------------------------------------
            // 2️⃣️⃣  Inner loop – up to max_iterations per base query
            // ----------------------------------------------------------------
            for (let i = 0; i < max_iterations; i++) {
                globalTurn++;
                searchMetrics.totalIterations = globalTurn;

                console.log(`[Iterative RAG] Turn ${globalTurn} – Query: "${currentQuery}"`);

                // ------------------------------------------------------------
                // Retrieve context for the current query
                // ------------------------------------------------------------
                const rawContext = await contextRetriever.retrieveContextForPrompt(
                    agent_id,
                    currentQuery,
                    context_options || {}
                );

                // Filter out already‑seen entities
                const newContext = rawContext.filter(ctx => {
                    const key = `${ctx.sourcePath}::${ctx.entityName ?? ''}`;
                    if (!processedEntities.has(key)) {
                        processedEntities.add(key);
                        return true;
                    }
                    return false;
                });

                // Deduplicate across the whole accumulated set (covers edge‑cases)
                const deduped = deduplicateContexts([...accumulatedContext, ...newContext]);
                const addedNow = deduped.length - accumulatedContext.length;
                accumulatedContext = rawContext; // update after deduplication
                accumulatedContext = deduped;

                // Update DMQR metric if applicable
                if (searchMetrics.dmqr.enabled && baseQueries.includes(currentQuery)) {
                    searchMetrics.dmqr.contextItemsGenerated += addedNow;
                }

                // Record per‑turn metrics
                searchMetrics.turnLog.push({
                    turn: globalTurn,
                    query: currentQuery,
                    newContextCount: addedNow,
                    decision: '',
                    reasoning: ''
                });

                console.log(`[Iterative RAG] Added ${addedNow} new context items (total unique: ${accumulatedContext.length}).`);

                // ------------------------------------------------------------
                // Build the analysis prompt and ask Gemini
                // ------------------------------------------------------------
                const formattedContext = formatContextForGemini(accumulatedContext)[0].text || '';
                const analysisPrompt = RAG_ANALYSIS_PROMPT
                    .replace('{originalQuery}', query)
                    .replace('{currentTurn}', String(globalTurn))
                    .replace('{maxIterations}', String(max_iterations))
                    .replace('{accumulatedContext}', formattedContext)
                    .replace('{focusString}', focusString)
                    .replace('{enableWebSearch}', String(!!enable_web_search));

                let analysisResult;
                try {
                    analysisResult = await this.geminiService.askGemini(
                        analysisPrompt,
                        model,
                        RAG_ANALYSIS_SYSTEM_INSTRUCTION,
                        thinkingConfig
                    );
                } catch (e: any) {
                    console.error('[Iterative RAG] Gemini analysis failed – aborting.', e);
                    searchMetrics.earlyTerminationReason = `Gemini analysis error: ${e.message}`;
                    break outer;
                }

                const rawResponse = analysisResult.content[0].text ?? '';
                const parsed = RagResponseParser.parseAnalysisResponse(rawResponse, formattedContext, analysisPrompt);
                if (!parsed) {
                    console.warn('[Iterative RAG] Unable to parse Gemini response – terminating.');
                    searchMetrics.earlyTerminationReason = 'Parsing failure';
                    break outer;
                }
                decisionLog.push(parsed);
                // Update turn log with decision info
                const turnLogEntry = searchMetrics.turnLog[searchMetrics.turnLog.length - 1];
                turnLogEntry.decision = parsed.decision;
                turnLogEntry.reasoning = parsed.reasoning;

                // ------------------------------------------------------------
                // React to the decision
                // ------------------------------------------------------------
                switch (parsed.decision) {
                    case 'ANSWER':
                        console.log('[Iterative RAG] // Decision: ANSWER – generating final answer.');
                        const answerPrompt = RAG_ANSWER_PROMPT
                            .replace('{originalQuery}', query)
                            .replace('{contextString}', formattedContext)
                            .replace('{focusString}', focusString);
                        const answerResult = await this.geminiService.askGemini(
                            answerPrompt,
                            model,
                            'You are a helpful AI assistant providing accurate answers based on the given context.',
                            thinkingConfig
                        );
                        const finalAnswer = answerResult.content[0].text ?? '';
                        // Optional hallucination verification
                        if (hallucination_check_threshold > 0) {
                            const hallucCheck = await this._performHallucinationCheck({
                                originalQuery: query,
                                contextString: formattedContext,
                                generatedAnswer: finalAnswer,
                                model,
                                threshold: hallucination_check_threshold,
                                thinkingConfig
                            });
                            if (hallucCheck.isHallucination) {
                                console.warn('[Iterative RAG] Hallucination detected – appending warning.');
                                const warning = `**Warning:** Possible hallucination detected. Issues: ${hallucCheck.issues}`;
                                return {
                                    accumulatedContext,
                                    webSearchSources,
                                    finalAnswer: `${finalAnswer}\n\n${'${warning}'}`,
                                    decisionLog,
                                    searchMetrics
                                };
                            }
                        }
                        return {
                            accumulatedContext,
                            webSearchSources,
                            finalAnswer,
                            decisionLog,
                            searchMetrics
                        };

                    case 'SEARCH_AGAIN':
                        if (!parsed.nextCodebaseQuery) {
                            console.warn('[Iterative RAG] SEARCH_AGAIN without a next query – terminating.');
                            searchMetrics.earlyTerminationReason = 'Missing nextCodebaseQuery';
                            break outer;
                        }
                        // Detect repetitive queries and expand if needed
                        if (this.isQueryRepetitive([...queryHistory, parsed.nextCodebaseQuery])) {
                            console.log('[Iterative RAG] Repetitive query detected – attempting expansion.');
                            const expanded = await this._expandQuery(
                                parsed.nextCodebaseQuery,
                                accumulatedContext,
                                model,
                                thinkingConfig
                            );
                            currentQuery = expanded;
                        } else {
                            currentQuery = parsed.nextCodebaseQuery;
                        }
                        queryHistory.push(currentQuery);
                        break;

                    case 'SEARCH_WEB':
                        if (!enable_web_search) {
                            console.warn('[Iterative RAG] Web search requested but disabled – ignoring.');
                            break;
                        }
                        if (!parsed.nextWebQuery) {
                            console.warn('[Iterative RAG] SEARCH_WEB without query – terminating.');
                            searchMetrics.earlyTerminationReason = 'Missing nextWebQuery';
                            break outer;
                        }
                        searchMetrics.webSearchesPerformed++;
                        try {
                            const webResults = await callTavilyApi(parsed.nextWebQuery, {
                                search_depth: tavily_search_depth,
                                max_results: tavily_max_results,
                                include_raw_content: tavily_include_raw_content,
                                include_images: tavily_include_images,
                                include_image_descriptions: tavily_include_image_descriptions,
                                time_period: tavily_time_period,
                                topic: tavily_topic
                            });
                            for (const r of webResults) {
                                webSearchSources.push({ title: r.title, url: r.url });
                                accumulatedContext.push({
                                    type: 'documentation',
                                    sourcePath: r.url,
                                    entityName: r.title,
                                    content: r.content,
                                    relevanceScore: 0.95
                                });
                            }
                        } catch (e: any) {
                            console.error('[Iterative RAG] Web search failed – continuing without web results.', e);
                        }
                        // After web search we stay on the same code query (no change)
                        break;

                    default:
                        console.warn(`[Iterative RAG] Unknown decision "${parsed.decision}" – terminating.`);
                        searchMetrics.earlyTerminationReason = `Unknown decision ${parsed.decision}`;
                        break outer;
                }
            } // end inner loop
        } // end outer loop

        // --------------------------------------------------------------------
        // Fallback – we never got an explicit ANSWER decision.
        // --------------------------------------------------------------------
        console.log('[Iterative RAG] No explicit ANSWER decision – generating fallback answer from accumulated context.');
        const fallbackContext = formatContextForGemini(accumulatedContext)[0].text || '';
        const fallbackPrompt = RAG_ANSWER_PROMPT
            .replace('{originalQuery}', query)
            .replace('{contextString}', fallbackContext)
            .replace('{focusString}', focusString);
        const fallbackResult = await this.geminiService.askGemini(
            fallbackPrompt,
            model,
            'You are a helpful AI assistant providing accurate answers based on the given context.',
            thinkingConfig
        );
        const fallbackAnswer = fallbackResult.content[0].text ?? 'Unable to formulate an answer.';

        // Optional hallucination verification on fallback answer
        if (hallucination_check_threshold > 0) {
            const hallucCheck = await this._performHallucinationCheck({
                originalQuery: query,
                contextString: fallbackContext,
                generatedAnswer: fallbackAnswer,
                model,
                threshold: hallucination_check_threshold,
                thinkingConfig
            });
            if (hallucCheck.isHallucination) {
                console.warn('[Iterative RAG] Hallucination detected on fallback answer.');
                return {
                    accumulatedContext,
                    webSearchSources,
                    finalAnswer: `${fallbackAnswer}\n\n**Warning:** Possible hallucination detected. Issues: ${hallucCheck.issues}`,
                    decisionLog,
                    searchMetrics
                };
            }
        }

        // Record early‑termination reason if we fell out of the loop without ANSWER
        if (!searchMetrics.earlyTerminationReason) {
            searchMetrics.earlyTerminationReason = 'Max iterations reached without ANSWER decision';
        }

        return {
            accumulatedContext,
            webSearchSources,
            finalAnswer: fallbackAnswer,
            decisionLog,
            searchMetrics
        };
    }

    /**
     * Helper – expands a query using Gemini when the next query is too similar
     * to a previously seen one.
     */
    private async _expandQuery(
        originalQuery: string,
        accumulatedContext: RetrievedCodeContext[],
        model?: string,
        thinkingConfig?: any
    ): Promise<string> {
        if (accumulatedContext.length === 0) return originalQuery;

        const contextSnippet = accumulatedContext
            .slice(0, 5)
            .map(c => `${c.type}: ${c.entityName || 'unknown'} – ${c.content?.substring(0, 80)}...`)
            .join('\n');

        const expansionPrompt = `Based on the following short context, rewrite or broaden the original query so that it can retrieve additional relevant information.

Original query: "${originalQuery}"
Context snippet:
${contextSnippet}

Return ONLY the new query string, no explanation.`;

        try {
            const result = await this.geminiService.askGemini(
                expansionPrompt,
                model,
                'You are a query expansion specialist. Return only the expanded query.',
                thinkingConfig
            );
            const newQuery = result.content[0].text?.trim();
            return newQuery && newQuery !== originalQuery ? newQuery : originalQuery;
        } catch (e: any) {
            console.error('[Iterative RAG] Query expansion failed – using original query.', e);
            return originalQuery;
        }
    }

    /**
     // Perform hallucination verification after an answer is generated.
     */
    private async _performHallucinationCheck(params: {
        originalQuery: string;
        contextString: string;
        generatedAnswer: string;
        model?: string;
        threshold: number;
        thinkingConfig?: { thinkingBudget?: number; thinkingMode?: 'AUTO' | 'MODE_THINK' };
    }): Promise<{ isHallucination: boolean; confidence: number; issues: string }> {
        const { originalQuery, contextString, generatedAnswer, model, threshold, thinkingConfig } = params;

        const verificationPrompt = RAG_VERIFICATION_PROMPT
            .replace('{originalQuery}', originalQuery)
            .replace('{contextString}', contextString)
            .replace('{generatedAnswer}', generatedAnswer);

        let verificationResult;
        try {
            verificationResult = await this.geminiService.askGemini(
                verificationPrompt,
                model,
                'You are a precise fact‑checker. Respond ONLY with VERIFIED or HALLUCINATION_DETECTED followed by issues.',
                thinkingConfig
            );
        } catch (e: any) {
            console.error('[Iterative RAG] Hallucination check failed.', e);
            return {
                isHallucination: false,
                confidence: 0,
                issues: `Verification failed: ${e.message}`
            };
        }

        const text = verificationResult.content[0].text ?? '';
        const isHallucination = text.includes('HALLUCINATION_DETECTED');
        return {
            isHallucination,
            confidence: isHallucination ? 0.9 : 0.1,
            issues: isHallucination ? text.replace('HALLUCINATION_DETECTED', '').trim() : 'No hallucination detected'
        };
    }

    /**
     * Detect whether the query history contains a highly similar repeat.
     */
    private isQueryRepetitive(queryHistory: string[]): boolean {
        if (queryHistory.length < 2) return false;
        const last = queryHistory[queryHistory.length - 1];
        for (let i = 0; i < queryHistory.length - 1; i++) {
            if (this.calculateSimilarity(last, queryHistory[i]) > 0.9) return true;
        }
        return false;
    }

    /**
     * Simple Jaccard‑style similarity – sufficient for repetition detection.
     */
    private calculateSimilarity(a: string, b: string): number {
        const setA = this.tokenSet(a);
        const setB = this.tokenSet(b);
        const intersection = new Set([...setA].filter(x => setB.has(x)));
        const union = new Set([...setA, ...setB]);
        return union.size === 0 ? 0 : intersection.size / union.size;
    }

    private tokenSet(text: string): Set<string> {
        return new Set(text.toLowerCase().split(/\s+/).filter(Boolean));
    }
}
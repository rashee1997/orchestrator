// src/database/query/QueryEngine.ts
import { JsonlStorageManager } from '../storage/JsonlStorageManager.js';
import path from 'path';

/**
 * Defines the structure for a parsed complex query string.
 * This AST (Abstract Syntax Tree) type is generated by `parseQuery`
 * when it successfully parses a string like "entityType:function file:src/utils.ts obs:details".
 */
export interface ParsedComplexQuery {
    type: 'parsed_complex_search';
    targetEntityType?: string;    // From entityType:value
    nameContains?: string;        // From name:value
    filePathCondition?: string;   // From file:value (checks node.name or observations)
    observationContains?: string[]; // From one or more obs:value
    idEquals?: string;            // From id:value
    limit?: number;               // From limit:value
    // Add other specific fields as needed for other key:value pairs
}

/**
 * Defines the structure for a simple keyword search.
 */
export interface SimpleSearchQuery {
    type: 'simple_search';
    query: string; // The raw keyword string
}

/**
 * Defines the structure for queries directly generated by NLPQueryProcessor.
 * This is kept for compatibility if NLPQueryProcessor produces these.
 */
export interface NlpStructuredQuery {
    type: string; // Could be 'search', 'traverse', etc.
    entities?: string[]; // Names of entities
    entityTypes?: string[]; // Types of entities
    relationTypes?: string[];
    filters?: Record<string, any>; // e.g., { isTest: true, pattern: "some_pattern_in_obs" }
    depth?: number;
    limit?: number;
    originalQuery?: string;
}

/**
 * Union type for all possible query AST structures.
 */
export type QueryAST = ParsedComplexQuery | SimpleSearchQuery | NlpStructuredQuery | any; // 'any' for flexibility with existing NLP output

export class QueryEngine {
    private jsonlStorage: JsonlStorageManager;

    constructor(jsonlStorage: JsonlStorageManager) {
        this.jsonlStorage = jsonlStorage;
    }

    /**
     * Parses a query string or a structured query object into an AST.
     * - If `query` is an object, it's assumed to be a pre-structured query (e.g., from NLPQueryProcessor) and is returned as is.
     * - If `query` is a string, it attempts to parse it for key:value patterns.
     * - If patterns like "entityType:value", "file:value", "obs:value" are found, it returns a `ParsedComplexQuery` AST.
     * - Otherwise, it returns a `SimpleSearchQuery` AST for basic keyword matching.
     * @param query The query string (e.g., "entityType:function file:src/utils.ts") or a structured query object.
     * @returns A QueryAST object.
     */
    parseQuery(query: string | any): QueryAST {
        // console.log(`[QueryEngine.parseQuery] Received query:`, query, `(Type: ${typeof query})`); // Initial log

        if (typeof query === 'object' && query !== null) {
            // console.log(`[QueryEngine.parseQuery] Query is an object, returning as NlpStructuredQuery (or similar):`, JSON.stringify(query));
            return query as NlpStructuredQuery;
        }

        if (typeof query === 'string') {
            const complexQuery: ParsedComplexQuery = { type: 'parsed_complex_search', observationContains: [] };
            let isComplex = false;
            const remainingQueryParts: string[] = [];
            let lastIndex = 0;

            // Regex to match key:value pairs, allowing for quoted values
            // Handles keys like entityType, file, name, obs, id, limit
            const patternRegex = /(\w+):(?:("([^"]+)")|(\S+))/g;
            let match;

            while ((match = patternRegex.exec(query)) !== null) {
                if (match.index > lastIndex) {
                    const prefix = query.substring(lastIndex, match.index).trim();
                    if (prefix) remainingQueryParts.push(prefix);
                }
                
                isComplex = true;
                const key = match[1].toLowerCase();
                const value = match[3] !== undefined ? match[3] : match[4]; // Group 3 for quoted, 4 for unquoted

                switch (key) {
                    case 'entitytype':
                        complexQuery.targetEntityType = value;
                        break;
                    case 'file':
                        complexQuery.filePathCondition = value;
                        break;
                    case 'name':
                        complexQuery.nameContains = value;
                        break;
                    case 'obs':
                        if (!complexQuery.observationContains) complexQuery.observationContains = [];
                        complexQuery.observationContains.push(value);
                        break;
                    case 'id':
                        complexQuery.idEquals = value;
                        break;
                    case 'limit':
                        const limitVal = parseInt(value, 10);
                        if (!isNaN(limitVal)) {
                            complexQuery.limit = limitVal;
                        }
                        break;
                    default:
                        // If key is not recognized, add the whole match to remainingQueryParts
                        // This helps capture parts of the query that don't fit the key:value structure
                        // but might be intended as general search terms.
                        remainingQueryParts.push(match[0]); 
                        break;
                }
                lastIndex = patternRegex.lastIndex;
            }
            
            if (lastIndex < query.length) {
                const suffix = query.substring(lastIndex).trim();
                if (suffix) remainingQueryParts.push(suffix);
            }

            if (isComplex) {
                if (complexQuery.observationContains?.length === 0) {
                    delete complexQuery.observationContains;
                }
                const generalSearchTerm = remainingQueryParts.join(' ').trim();
                if (generalSearchTerm) {
                    if (!complexQuery.nameContains && (!complexQuery.observationContains || complexQuery.observationContains.length === 0)) {
                        complexQuery.nameContains = generalSearchTerm;
                    } else {
                         if (!complexQuery.observationContains) {
                            complexQuery.observationContains = [];
                        }
                        complexQuery.observationContains.push(generalSearchTerm);
                    }
                }
                // console.log(`[QueryEngine.parseQuery] Parsed as ParsedComplexQuery:`, JSON.stringify(complexQuery));
                return complexQuery;
            } else {
                // No key:value patterns found, treat as a simple keyword search
                const simpleQuery = { type: 'simple_search', query: query.trim() } as SimpleSearchQuery;
                // console.log(`[QueryEngine.parseQuery] Parsed as SimpleSearchQuery:`, JSON.stringify(simpleQuery));
                return simpleQuery;
            }
        }

        console.warn("[QueryEngine.parseQuery] Received an unexpected query type, defaulting to simple_search:", query);
        return { type: 'simple_search', query: String(query) } as SimpleSearchQuery;
    }


    /**
     * Executes a parsed query AST against the knowledge graph data for a given agent.
     * @param ast The QueryAST object.
     * @param agentId The ID of the agent whose data is being queried.
     * @returns A Promise resolving to an object containing the filtered nodes.
     */
    async executeQuery(ast: QueryAST, agentId: string): Promise<{ nodes: any[] }> {
        // console.log(`[QueryEngine.executeQuery] AST received:`, JSON.stringify(ast)); // Log the AST
        if (!agentId || typeof agentId !== 'string' || agentId.trim() === '') {
            console.error('[QueryEngine.executeQuery] ERROR: agentId is invalid or missing.');
            return { nodes: [] };
        }
        
        const nodesFilePath = path.join(agentId, 'nodes.jsonl');
        let allNodes;
        try {
            allNodes = await this.jsonlStorage.readAllLines(nodesFilePath);
            // console.log(`[QueryEngine.executeQuery] Read ${allNodes.length} nodes from ${nodesFilePath} for agent ${agentId}.`);
        } catch (error) {
            console.error(`[QueryEngine.executeQuery] ERROR: reading ${nodesFilePath} for agent ${agentId}:`, error);
            return { nodes: [] };
        }

        if (!Array.isArray(allNodes)) {
            console.error(`[QueryEngine.executeQuery] ERROR: Expected array from readAllLines for ${nodesFilePath}, got:`, typeof allNodes);
            return { nodes: [] };
        }

        let filteredNodes = allNodes.filter((node: any) => node && !node.deleted);
        // console.log(`[QueryEngine.executeQuery] Initial non-deleted nodes: ${filteredNodes.length}`);

        if (ast.type === 'parsed_complex_search') {
            const complexAst = ast as ParsedComplexQuery;
            // console.log('[QueryEngine.executeQuery] Processing ParsedComplexQuery AST:', JSON.stringify(complexAst));

            if (complexAst.targetEntityType) {
                const entityTypeLower = complexAst.targetEntityType.toLowerCase();
                filteredNodes = filteredNodes.filter(node => node.entityType && node.entityType.toLowerCase() === entityTypeLower);
                // console.log(`[QueryEngine.executeQuery] Nodes after entityType filter ('${entityTypeLower}'): ${filteredNodes.length}`);
            }
            if (complexAst.nameContains) {
                const nameLower = complexAst.nameContains.toLowerCase();
                filteredNodes = filteredNodes.filter(node => node.name && node.name.toLowerCase().includes(nameLower));
                // console.log(`[QueryEngine.executeQuery] Nodes after nameContains filter ('${nameLower}'): ${filteredNodes.length}`);
            }
            if (complexAst.idEquals) {
                filteredNodes = filteredNodes.filter(node => node.id === complexAst.idEquals);
                // console.log(`[QueryEngine.executeQuery] Nodes after idEquals filter: ${filteredNodes.length}`);
            }
            if (complexAst.filePathCondition) {
                const filePathLower = complexAst.filePathCondition.toLowerCase();
                filteredNodes = filteredNodes.filter(node => {
                    if (node.name && node.entityType === 'file' && node.name.toLowerCase() === filePathLower) return true;
                    if (node.name && node.entityType === 'directory' && node.name.toLowerCase() === filePathLower) return true;
                    if (node.observations && Array.isArray(node.observations)) {
                        return node.observations.some((obs: string) => obs && typeof obs === 'string' && obs.toLowerCase().includes(filePathLower));
                    }
                    return false;
                });
                // console.log(`[QueryEngine.executeQuery] Nodes after filePathCondition filter ('${filePathLower}'): ${filteredNodes.length}`);
            }
            if (complexAst.observationContains && complexAst.observationContains.length > 0) {
                complexAst.observationContains.forEach(obsQuery => {
                    if (obsQuery && obsQuery.trim() !== "") { // Ensure obsQuery is not empty
                        const obsQueryLower = obsQuery.toLowerCase();
                        filteredNodes = filteredNodes.filter(node =>
                            node.observations && Array.isArray(node.observations) &&
                            node.observations.some((obs: string) => obs && typeof obs === 'string' && obs.toLowerCase().includes(obsQueryLower))
                        );
                        // console.log(`[QueryEngine.executeQuery] Nodes after observationContains filter ('${obsQueryLower}'): ${filteredNodes.length}`);
                    }
                });
            }
            if (complexAst.limit && typeof complexAst.limit === 'number') {
                filteredNodes = filteredNodes.slice(0, complexAst.limit);
                // console.log(`[QueryEngine.executeQuery] Nodes after limit filter (${complexAst.limit}): ${filteredNodes.length}`);
            }
        } else if (ast.type === 'simple_search') {
            const simpleAst = ast as SimpleSearchQuery;
            // console.log('[QueryEngine.executeQuery] Processing SimpleSearchQuery AST:', JSON.stringify(simpleAst));
            if (simpleAst.query && simpleAst.query.trim() !== "") {
                const lowerQuery = simpleAst.query.toLowerCase();
                filteredNodes = filteredNodes.filter((node: any) => {
                    const nameMatch = node.name && node.name.toLowerCase().includes(lowerQuery);
                    const typeMatch = node.entityType && node.entityType.toLowerCase().includes(lowerQuery);
                    let observationsMatch = false;
                    if (node.observations && Array.isArray(node.observations)) {
                        observationsMatch = node.observations.some((obs: string) => obs && typeof obs === 'string' && obs.toLowerCase().includes(lowerQuery));
                    }
                    return nameMatch || typeMatch || observationsMatch;
                });
                // console.log(`[QueryEngine.executeQuery] Nodes after simple_search filter ('${lowerQuery}'): ${filteredNodes.length}`);
            }
        } else {
            // Handling for NlpStructuredQuery (original structured query from NLPQueryProcessor or other direct structured inputs)
            const nlpAst = ast as NlpStructuredQuery;
            // console.log('[QueryEngine.executeQuery] Processing NlpStructuredQuery compatible AST:', JSON.stringify(nlpAst));

            if (nlpAst.entities && nlpAst.entities.length > 0) {
                filteredNodes = filteredNodes.filter(node => nlpAst.entities!.includes(node.name));
                // console.log(`[QueryEngine.executeQuery] Nodes after nlpAst.entities filter: ${filteredNodes.length}`);
            }
            if (nlpAst.entityTypes && nlpAst.entityTypes.length > 0) {
                filteredNodes = filteredNodes.filter(node => nlpAst.entityTypes!.includes(node.entityType));
                // console.log(`[QueryEngine.executeQuery] Nodes after nlpAst.entityTypes filter: ${filteredNodes.length}`);
            }
            if (nlpAst.filters) {
                for (const [key, value] of Object.entries(nlpAst.filters)) {
                    if (key === 'isTest' && value === true) {
                        filteredNodes = filteredNodes.filter(node => node.name && (node.name.includes('.test') || node.name.includes('.spec')));
                    }
                    if (key === 'entityType' && typeof value === 'string') {
                        filteredNodes = filteredNodes.filter(node => node.entityType === value);
                    }
                    if (key === 'pattern' && typeof value === 'string') {
                        const patternLower = value.toLowerCase();
                        filteredNodes = filteredNodes.filter(node =>
                            node.observations && Array.isArray(node.observations) &&
                            node.observations.some((obs: string) => obs && typeof obs === 'string' && obs.toLowerCase().includes(patternLower))
                        );
                    }
                }
                // console.log(`[QueryEngine.executeQuery] Nodes after nlpAst.filters application: ${filteredNodes.length}`);
            }
            if (nlpAst.limit && typeof nlpAst.limit === 'number') {
                filteredNodes = filteredNodes.slice(0, nlpAst.limit);
                // console.log(`[QueryEngine.executeQuery] Nodes after nlpAst.limit filter: ${filteredNodes.length}`);
            }
        }
        // console.log(`[QueryEngine.executeQuery] Final filtered nodes count: ${filteredNodes.length}`);
        return { nodes: filteredNodes };
    }

    optimizeQuery(ast: QueryAST): QueryAST {
        return ast;
    }
}
